Encapsulation: private instance variables, access/modify it with public getters/setters

Polymorphic method invocation:

Animal animal = new Horse();
animal.eat();

- if class Horse has method buck(): 

animal.buck(); - !!! WRONG !!! - does not compile

- at compile time, reference type (Animal) matters, only methods from reference type are available, so class Animal must have buck() method
- at runtime real type (Horse) matters, so eat() method of Horse class version is called
- if eat() in Animal throws a checked exception, then animal.eat() must catch or declare the exception, even if eat() in Horse does not throws any exception
- this works ONLY for instance methods, NOT variables, NOT static methods

Overriding 
- !!! RUN TIME based on object real type !!!         
- method in subclass CAN NOT be more restrictive then method in superclass          
- method version is choosen at run time based on real type of object, not reference type                      
- method in subclass CAN throw any runtime exception         
- method in subclass CAN NOT throw other or broader checked exception then method in superclass                     
- static methods CAN NOT be overriden, can be redefined

Overloading 
- !!! COMPILE TIME based on reference type !!!           
- MUST change the argument list           
- CAN change return type, but not only this          
- CAN change access modifier           
- CAN declare new or broader checked exception

public void doStuff(Animal a) { } 
public void doStuff(Horse h) { }
Animal animal = new Horse();
animal.doStuff(animal);

- when multiple overloaded methods, method to execute is choosen at COMPILE TIME based on REFERENCE TYPE not real object type, in this case Animal not Horse,
so doStuff(Animal a) is executed

Cast: 
- downcast to access a specific Horse method on Animal animal = new Horse(), in this case: Horse horse = (Horse) animal;     
- works only if real object type is Horse      
- recomended to be checked with instanceof           
- if cast is wrong and classes in same inheritance tree, code compiles, throws ClassCastException at runtime; ex; Dog dog = (Animal) animal;      
- if cast is wrong and classes not in same inheritance tree, compilation error; ex: String s = (String) animal;     
- upcast works implicitly

Ex: ((Dog) new Hound()).bark(); // Hound extends Dog

- equivalent with: 

Hound hound = new Hound();
Dog dog = (Dog) hound;
dog.bark();

- at compile time, class Dog must have method bark(); dog real type is Hound, so at run time, bark() from Hound class is called

Interface implementation: 
- methods implementation same as overriding

Return types:
- null CAN be returned

Covariant returns: 
- applies on overriding, only since Java 5                   
- return type of subclass method can be a sublcass of return type of superclass method;

Constructors: 
- no-args constructor is generated by default with class access modifier, only if no other constructor is provided              
- in every constructor first line is super() or this(); if you not type it, this line is inserted by compiler              
- if you want super() with arguments, you must type it in, compiler insert only super() without any argument

Animal(int size) { } // constructor in superclass 
Horse() { } // constructor in subclass - PROBLEM!!! compiler will insert super(); but there is no no-args superconstructor

- any constructor in class Horse() must contain super(String size) (in this case) or this(), else compiler will put in by default super() with no arguments 
- since superclass does not have a no-args constructor, code will not compile
- if Animal() throws a checked exception, then Horse() must declare or catch the exception, because in the first line super() calls superconstructor
- cannot use instance variables or instance methods before superconstructor runs
- cannot use instance variables or instance methods as arguments for super() and this()

Statics: 
- !!!WATCH OUT!!! for use of nonstatic variables or methods in static methods        
- no overriding, polymorphism does not works, only redefining

Animal animal = new Horse();
animal.callStaticMethod();

- if callStaticMethod() in both Animal and Horse classes, Animal version method will be called; is like Animal.callStaticMethod()

Loose coupling: - referes to relations between classes; a class must know as less as possible about the other classes
High cohesion: - a class must have a well focused purpose